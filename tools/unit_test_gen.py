
"""A tool for generating .asm files that run unit tests for asm functions.

Rather than trying to actually document everything, see meta_test.py as an example.
"""

import os
import random
import sys
import time

from easycmd import cmd
import argh


class Memory(object):
	def __init__(self, *args):
		self.contents = []
		for arg in args:
			try:
				i = iter(arg)
			except TypeError:
				self.contents.append(arg)
			else:
				self.contents += list(i)


test_order = 0
class Test(object):
	def __init__(self, target=None, **kwargs):
		global test_order
		self.order = test_order
		test_order += 1

		self.target = target
		self.ins = {
			'regs': {},
			'flags': {},
			'mems': {},
		}
		self.outs = {
			'regs': {},
			'flags': {},
			'mems': {},
		}
		for key, value in kwargs.items():
			if key.startswith('in_'):
				state = self.ins
			elif key.startswith('out_'):
				state = self.outs
			else:
				raise ValueError("Bad keyword: {!r} (must be specified 'in_' or 'out_')".format(key))
			_, name = key.split('_', 1)

			if isinstance(value, Memory):
				state['mems'][name] = value.contents
			elif name in ('zflag', 'cflag'):
				flag = name[0]
				state['flags'][flag] = value
			elif name in ['A', 'B', 'C', 'D', 'E', 'H', 'L']:
				state['regs'][name] = value
			elif name in ('BC', 'DE', 'HL'):
				high, low = name
				state['regs'][high] = '({}) >> 8'.format(value)
				state['regs'][low] = '({}) & $ff'.format(value)
			else:
				raise ValueError("Bad keyword: {!r} (not a reg, flag or Memory)".format(key))

	def gen_asm(self, include_asm, target, extra_asm, mems):
		if self.target is not None:
			target = self.target

		return """
; --- GENERATED BY {argv[0]} on {now} ---


; --- original target file ---
{include_asm}


; --- extra asm from test spec (may be empty) ---
{extra_asm}

; --- test harness ---
SECTION "{argv[0]} test stack", WRAM0

ds 128
_TestStack::

SECTION "{argv[0]} header", ROM0 [$100]
; This must be nop, then a jump, then blank up to 150
_Start::
	nop
	jp _TestStart
_Header::
	ds 76 ; Linker will fill this in

SECTION "{argv[0]} test harness", ROM0

_TestFailure::
	ld HL, $dead
	jp _TestFailure

_TestSuccess::
	ld HL, $face
	jp _TestSuccess

_TestStart::
xor A
ld [$ffff], A ; Disable all interrupts
ld SP, _TestStack
; set up test
{prepare}
; run test
call {target}
; check results
{check}
jp _TestSuccess
""".format(
	argv=sys.argv,
	now=time.strftime("%F %T"),
	include_asm=include_asm,
	extra_asm=extra_asm,
	prepare=self.gen_asm_prepare(mems),
	target=target,
	check=self.gen_asm_check(),
)

	def gen_asm_prepare(self, global_mems):
		regs = self.ins['regs']
		flags = self.ins['flags']
		local_mems = self.ins['mems']

		# merge mems. in the simple case, use either
		mems = global_mems.copy()
		mems.update(local_mems)
		# the only hard case is when both have it - we favor local_mems but if global_mems
		# is longer then we take the remainder from there
		for label in set(local_mems) & set(global_mems):
			l, g = local_mems[label], global_mems[label]
			mems[label] = l + g[len(l):]

		# our approach: mems first, then flags, then regs
		lines = []
		for label, values in mems.items():
			lines += ["ld HL, {}".format(label)]
			for value in values:
				lines += [
					"ld [HL], {}".format(value),
					"inc HL",
				]
		for flag, value in flags.items():
			if flag == 'z':
				if value:
					lines += ["xor A"]
				else:
					lines += ["or $ff"]
			elif flag == 'c':
				lines += ['scf'] # set carry
				if not value:
					lines += ['ccf'] # flip carry, ie. unset since we just set it
		for reg, value in regs.items():
			lines += ["ld {}, {}".format(reg, value)]

		return '\n'.join(lines)

	def gen_asm_check(self):
		regs = self.outs['regs']
		flags = self.outs['flags']
		mems = self.outs['mems']

		# we need to be careful here not to clobber state as we go.
		# we check flags, then reg A, then other regs, then mems.
		lines = []
		for flag, value in flags.items():
			predicate = '{}{}'.format(('n' if value else ''), flag) # eg. for z, True -> 'nz'
			lines += ["jp {}, _TestFailure".format(predicate)]
		# special case reg A since we need to check it first
		if 'A' in regs:
			value = regs['A']
			lines += [
				'cp {}'.format(value),
				'jp nz, _TestFailure',
			]
		for reg, value in regs.items():
			if reg == 'A':
				continue
			lines += [
				'ld A, {}'.format(reg),
				'cp {}'.format(value),
				'jp nz, _TestFailure',
			]
		for label, values in mems.items():
			lines += ["ld HL, {}".format(label)]
			for value in values:
				lines += [
					'ld A, [HL+]',
					'cp {}'.format(value),
					'jp nz, _TestFailure',
				]
		return '\n'.join(lines)


def process_file(top_level_dir, include_dir, tests_dir, filename):
	name, _ = os.path.splitext(filename)
	filepath = os.path.join(tests_dir, filename)
	config = dict(Memory=Memory, Test=Test, random=random.Random(name))
	execfile(filepath, config) # loads config as defined globals
	if 'file' not in config:
		raise ValueError("You must specify a target file, or None")
	include_file = config['file']
	link_files = config.get('files', [])
	target = config.get('target')
	extra_asm = config.get('asm', '')
	mems = {label: value.contents for label, value in config.items() if isinstance(value, Memory) and not label.startswith('_')}
	tests = {testname: test for testname, test in config.items() if isinstance(test, Test)}
	if target is None and any(test.target is None for test in tests.values()):
		raise ValueError("You must specify a target function, either at top-level or for every test case")

	if include_file is None:
		include_asm = ''
	else:
		include_path = os.path.join(top_level_dir, '{}.asm'.format(include_file))
		with open(include_path) as f:
			include_asm = f.read()

	link_paths = [os.path.join(top_level_dir, '{}.o'.format(link_file)) for link_file in link_files]

	gendir = os.path.join(tests_dir, name)
	if not os.path.exists(gendir):
		os.mkdir(gendir)

	for i, (testname, test) in enumerate(sorted(tests.items(), key=lambda (n,t): t.order)):
		testname = '{i:0{w}d}_{t}'.format(i=i, t=testname, w=len(str(len(tests)-1)))
		asm = test.gen_asm(include_asm, target, extra_asm, mems)
		path = os.path.join(gendir, testname)
		asm_path = '{}.asm'.format(path)
		obj_path = '{}.o'.format(path)
		sym_path = '{}.sym'.format(path)
		rom_path = '{}.gb'.format(path)
		with open(asm_path, 'w') as f:
			f.write(asm)
		cmd(['rgbasm', '-i', include_dir, '-v', '-o', obj_path, asm_path])
		cmd(['rgblink', '-n', sym_path, '-o', rom_path, obj_path] + link_paths)
		cmd(['rgbfix', '-v', '-p', 0, rom_path])


def main(top_level_dir, include_dir='include/', tests_dir='tests'):
	include_dir = os.path.join(top_level_dir, include_dir)
	tests_dir = os.path.join(top_level_dir, tests_dir)
	for filename in os.listdir(tests_dir):
		if filename.endswith('.py'):
			process_file(top_level_dir, include_dir, tests_dir, filename)


if __name__ == '__main__':
	argh.dispatch_command(main)
